<html>
<head>
<title>
    cowitch-19 - pseudo-scientific curve prediction yay!
</title>

<!--TODO:

- fix interface:
    - remove smogdance data
    - add correct datetime to labels
    - fix colors and graph style
- add graph for rate of spread
- add a way to access older states (eg. state from 22.3, etc)
- add a small probabilistic jitter to the scenario, run several times:
    - rate of spread jitter
    - speed / rate of decline jitter
- add several scenarios (current, optimistic)
- look into dead / healthy - cumulative or not ?
- add healed / dead / new per day
- add tables to graphs
- add interface to change params from web

- use the SIER methodology to predict longterm
- population size, immune pool, dead pool, etc

-->

<!-- MOMENT.JS -->
<script src="moment.js"></script>

<!-- CHART.JS -->
<script src="Chart.min.js"></script>

<!-- PALETTE.JS -->
<script src="palette.js"></script>

<!-- MOBILE & DESKTOP STYLES -->
<link rel="stylesheet" media='screen' href="style.css"/>

</head>
<body style="margin: 0;">
    <div id="nav_top" style="width: 99%; padding-left: 1%; padding-top: 0.5%; border-bottom: 1px solid black; padding-bottom: 1%;">
        sum linkz ere
    </div>
    <div class="chart-container" style="padding-left: 1%; position: relative; width:85%; height:83%;">
		<canvas id="full"></canvas>
	</div>
	<br/><br/><br/>
    <div id="nav_bottom" style="width: 100%; background-color: gold; border: 2px; border-color: black;">
        <div style="padding-left: 1%; float: left;">Moar linkz ere:
			<button id='trololo' style="width: 50px; height: 20px; background-color: gold; border: 0px;" onclick="some_function('pm10');">pm10</button>
			&nbsp;
			<button id='tra tra' style="width: 50px; height: 20px; background-color: yellow; border: 0px;" onclick="some_function('pm25');">pm25</button>
			&nbsp;
		</div>
    </div>
</body>
<script>
    model = {};
    MAXDAYS = 180;

    // Get maximum value for array
    function get_max(arr) {
        max = 0;
        for (var i=0; i < arr.length; i++) {
            max = Math.max( arr[i], max );
        }
        return max;
    }

    // This is a log
    function log_decrease(day, speed) {
        return Math.log10(day)/speed;
    }

    // This computes the average infection rate for days with data
    function avg_infection_rate(data) {
        var sum = 0;
        for (var i=0; i < data.length; i++) {
            sum += data[i];
        }
        return sum / data.length;
    }

    // This computes the amount of people getting helthy on a given day
    // Earliest recovery is after 11 days, latest recovery after 35 days
    // For data these two studies were used:
    //      [1] Clinical Characteristics of 138 Hospitalized Patients With 2019 Novel Coronavirusâ€“Infected Pneumonia in Wuhan, China
    //      [2] Clinical features of patients infected with 2019 novel coronavirus in Wuhan, China
    //
    // We use this kind of distribution [3]:
    // 80% - 14-17 days - mild cases
    // 6% - 18-20 days - hospitalisation, median time to admission 10 days, median time to release 10 days
    // 13% - 21-35 days - severe hospitalisation
    // 1% - day 20-30 - dead
    //
    // To make things simpler the above can be represented like this:
    // 1,2,3,7,18,20,17,13,3,2,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,1,1,1,1
    //
    //
    // Where the first number is the percentage of healed cases on day 11, the next one is the percentage of healed on day 12, and so on
    //
    // This makes for a nice smooth curve which fullfills the above criteria [3].
    // The 0.9% on days 20-30 makes up for 1% death rate - so far Covid-19 has been having a low death rate in CZ (also in neighboring DE)..
    //
    // For easier handling, we send in an array of daily infected people starting 34 days before,
    // and ending 11 days before the day we try to compute number of healed persons
    function healthy(arr) {
        sum = 0;
        sum += 0.01 * arr[0]; // day 34
        sum += 0.01 * arr[1];
        sum += 0.01 * arr[2];
        sum += 0.01 * arr[3];
        sum += 0.009 * arr[4];
        sum += 0.009 * arr[5];
        sum += 0.009 * arr[6];
        sum += 0.009 * arr[7];
        sum += 0.009 * arr[8];
        sum += 0.009 * arr[9];
        sum += 0.009 * arr[10];
        sum += 0.009 * arr[11];
        sum += 0.009 * arr[12];
        sum += 0.009 * arr[13];
        sum += 0.02 * arr[14];
        sum += 0.03 * arr[15];
        sum += 0.13 * arr[16];
        sum += 0.17 * arr[17];
        sum += 0.20 * arr[18];
        sum += 0.18 * arr[19];
        sum += 0.07 * arr[20];
        sum += 0.03 * arr[21];
        sum += 0.02 * arr[22];
        sum += 0.01 * arr[23]; // day 11
        return sum;
    }

    // See above
    function dead(arr) {
        sum = 0;
        sum += 0.001 * arr[0]; // day 30
        sum += 0.001 * arr[1];
        sum += 0.001 * arr[2];
        sum += 0.001 * arr[3];
        sum += 0.001 * arr[4];
        sum += 0.001 * arr[5];
        sum += 0.001 * arr[6];
        sum += 0.001 * arr[7];
        sum += 0.001 * arr[8];
        sum += 0.001 * arr[9]; // day 20
        return sum;
    }

    // Sort of struct emulation in js
    function params(name, model_duration, infection_rate_seed, decay_func, decay_speed, decay_min, new_seed) {
        this.name = name;
        this.model_duration = model_duration;
        this.irs = infection_rate_seed;
        this.decay_func = decay_func;
        this.decay_speed = decay_speed;
        this.decay_min = decay_min;
        this.new_seed = new_seed;
    }

    function run_model(params) {
        // setup arrays
        model[params.name] = {}
        model[params.name]['rate'] = [];
        model[params.name]['new'] = [];
        model[params.name]['daily'] = [3];
        model[params.name]['healed'] = [0];
        model[params.name]['deaths'] = [0];
        model[params.name]['total'] = [0];

        // seed & compute infection rate
        for (var i=0; i < params.model_duration; i++) {
            // if we have provided a value, use it
            if (i in params.irs) {
                model[params.name]['rate'].push( params.irs[i] );
            } else {
                // otherwise determine next value from the previous one
                // we need to seed at least the first value
                if (i > 0) {
                    // decrease by log(day_number)/speed
                    if (params.decay_func == 'log') {
                        new_rate = model[params.name]['rate'][i-1] - log_decrease(i+1, params.decay_speed);
                    }
                    // check if new_rate over allowed min
                    new_rate = Math.max( new_rate, params.decay_min );

                    // add rate into model
                    model[params.name]['rate'].push( new_rate );
                }
            }
        }

        // compute the projected
        for (var i=0; i < params.model_duration; i++) {
            var new_infected, new_daily, healed, died, total;

            // New
            if (i in params.new_seed) {
                new_infected = params.new_seed[i];
                model[params.name]['new'].push( new_infected );
                //console.log('new infected[' + i + '] = ' + new_infected );
            } else {
                // new infected are yesterda's total * yesterdays infection rate
                new_infected = model[params.name]['rate'][i-1] * model[params.name]['total'][i-1];
                model[params.name]['new'].push( new_infected );
                //console.log('new infected[' + i + '] = ' + model[params.name]['rate'][i-1] + ' * ' + model[params.name]['total'][i-1] );
            }

            // New per day
            if (i > 0) {
                new_daily = Math.max(model[params.name]['new'][i] - model[params.name]['total'][i-1], 0);
                model[params.name]['daily'].push( new_daily );
                //console.log('daily[' + i + '] = ' +  model[params.name]['new'][i] + ' - ' + model[params.name]['new'][i-1] );
            }

            // Healed per day
            if (i > 0) {
                // Create and fill the daily array slice starting at current day - 34 and ending at current day - 11
                daily_slice = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
                for (var j=34; j>10; j--) {
                    if (i-j > 0) {
                        daily_slice[34-j] = model[params.name]['daily'][i-j];
                    }
                }
                healed = healthy(daily_slice);
                model[params.name]['healed'].push( healed );
                //console.log('healed[' + i + '] = ' + healed );
            }

            // Deaths per day
            if (i > 0) {
                // Create and fill the daily array slice starting at current day - 30 and ending at current day - 20
                daily_slice = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
                for (var j=30; j>19; j--) {
                    if (i-j > 0) {
                        daily_slice[30-j] = model[params.name]['daily'][i-j];
                    }
                }
                died = dead(daily_slice);
                model[params.name]['deaths'].push( died );
                //console.log('deaths[' + i + '] = ' + died );
            }

            // Total = New - Healed - Died
            if (i > 0) {
                total = new_infected - healed - died;
                model[params.name]['total'].push( total );
                //console.log('total[' + i + '] = ' + new_infected + ' - ' + healed + ' - ' + died );
            }

            // Log to console
            if (i >0) {
                rate = model[params.name]['rate'][i];
                console.log((i+1)+' rate: '+rate.toFixed(2)+' new: '+new_infected.toFixed(0)+' day: '+new_daily.toFixed(0)+' healed: '+healed.toFixed(0)+' total: '+total.toFixed(0) + ' died: '+died.toFixed(0))
            }
        }
    }

    // Create the data array
    var data = {};
    data['infected_confirmed'] = [3,3,5,5,8,19,26,32,38,63,94,116,141,189,298,383,464,572,774,904,1047,1165,1289];
    data['infected_daily'] = [];
    data['infection_rate'] = [];
    data['infection_rate_avg'] = [];

    /////////////// Setup initial data' //////////////
    days_elapsed = data['infected_confirmed'].length;
    /// get daily new cases
    data['infected_daily'].push(data['infected_confirmed'][0]);
    for (var i=1; i < days_elapsed; i++) {
        data['infected_daily'].push( data['infected_confirmed'][i] - data['infected_confirmed'][i-1] );
    }
    /// get daily infection rate
    data['infection_rate'].push(1);
    for (var i=1; i < days_elapsed; i++) {
        data['infection_rate'].push( data['infected_confirmed'][i] / data['infected_confirmed'][i-1] );
    }
    /// get daily average infection rate
    data['infection_rate_avg'].push(1);
    for (var i=1; i < days_elapsed; i++) {
        data['infection_rate_avg'].push( avg_infection_rate( data['infection_rate'].slice(0,i+1) ) );
    }

    // create infection_rate seed for the model
    var rate_seed = {};
    for (var i=0; i < 20; i++) {
        rate_seed[i] = data['infection_rate_avg'][i];
    }
    rate_seed[20] = 1.2; // czech government enforced mandatory quarantaine on 14.3, we should start seeing the effects around 21.3

    // create infected seed for the model
    // data taken from https://onemocneni-aktualne.mzcr.cz/covid-19
    var new_seed = {};
    for (var i=0; i < days_elapsed; i++) {
        new_seed[i] = data['infected_confirmed'][i];
    }

    // put together the models parameters
    var model1 = new params(
        'Projekcia',
        MAXDAYS,
        rate_seed,
        'log',
        100,
        1.01,
        new_seed,
    );

    // run the model
    run_model( model1 );

    // the graph
    var full = document.getElementById("full").getContext('2d');
    var graph_height = window.innerHeight * 0.83;
    var grd = full.createLinearGradient(0, graph_height,  0,  0);
    var country_name = 'Czech republic';
    var models = ['Projekcia'];
    var chart_max = {};
	chart_max['Projekcia'] = get_max(model['Projekcia']['rate']);
    var pal = palette('mpn65', 1);
    var labels = [];
    for (var i=1; i<MAXDAYS; i++) {
        labels.push(i);
    }

    // HEX to R,G,B - taken from http://www.javascripter.net/faq/hextorgb.htm
    function hexToR(h) {return parseInt((cutHex(h)).substring(0,2),16)}
    function hexToG(h) {return parseInt((cutHex(h)).substring(2,4),16)}
    function hexToB(h) {return parseInt((cutHex(h)).substring(4,6),16)}
    function cutHex(h) {return (h.charAt(0)=="#") ? h.substring(1,7):h}

    // HEX to RGBA
    function hexToRGBA(h, alpha) {
        return "rgba(" + hexToR(h) + "," + hexToG(h) + "," + hexToB(h) + "," + alpha + ")";
    }

    // This takes care of data array switching and chart titles
    // when choosing different substances
    function change_substance(substance) {
        for (var i=0; i< window.myChart.data.datasets.length; i++) {
            var sensor_id = sensor_ids[i];
            if (data[sensor_id][substance]) {
                window.myChart.data.datasets[i].data = data[sensor_id][substance];
            } else {
                window.myChart.data.datasets[i].data = [];
            }
        }
        // change the chart title
        window.myChart.options.title.text = city_name + " " + substance.toUpperCase() + " (last 30 days)";
        // change active button color
        for (var i=0; i< city_substances.length; i++) {
            if (city_substances[i] == substance) {
                document.getElementById(city_substances[i]).style.backgroundColor = 'gold';
            } else {
                document.getElementById(city_substances[i]).style.backgroundColor = 'yellow';
            }
        }
        // change max chart values
        window.myChart.options.scales.yAxes[0].ticks.max = chart_max[substance];

        if (!city_chart) {
            // change chart gradient
            grd = full.createLinearGradient(0, graph_height,  0,  0);
            grd = change_thresholds(substance, grd);
            window.myChart.data.datasets[0].backgroundColor = grd;
        }

        // update chart
        window.myChart.update();
    }

    // create a legendCallback - see: https://github.com/chartjs/Chart.js/issues/2565
    function legendcallback(chart) {
        var legendHtml = [];
        legendHtml.push('<table>');
        legendHtml.push('<tr>');
        for (var i=0; i<chart.data.datasets.length; i++) {
            legendHtml.push('<td><div class="chart-legend" style="background-color:' + chart.data.datasets[i].borderColor + '"></div></td>');
            if (chart.data.datasets[i].label) {
                legendHtml.push(
                    '<td class="chart-legend-label-text" onclick="updateDataset(event, ' + '\'' + chart.legend.legendItems[i].datasetIndex + '\'' + ')">'
                     + chart.data.datasets[i].label + '</td>');
            }
        }
        legendHtml.push('</tr>');
        legendHtml.push('</table>');
        return legendHtml.join("");
    }

    // The chart
    window.myChart = new Chart(full, {
        type: 'line',
        data: { labels: labels,
		datasets: [ {
			label: 'Test',
			data: model['Projekcia']['total'],
			spanGaps: true,
			borderWidth: 1,
			borderColor: '#0000EE',
			pointStyle: 'cross',
			pointBackgroundColor: 'rgb(0,0,0)',
			pointBorderColor: 'rgb(0,0,0)',
			tension: 0.2
		}
	]
},
        options: {
            title: {
                display: true,
                text: 'Amurska, Kosice - pm10'
            },
            scales: {
                xAxes: [{
                    type: 'time',
                    time: {
                        unit: 'day'
                    }
                }],
                yAxes: [{
                    ticks: {
                        min: 0,
                        max: chart_max['pm10']                    }
                }]
            },
            legendCallback: legendcallback,
            legend: {
                display: true
            }
        }
    });
</script>
</html>
